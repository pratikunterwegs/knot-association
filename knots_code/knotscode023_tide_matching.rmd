---
chunk_output_type: console
editor_options: 
  chunk_output_type: console
---
```{r}
source("libs.R");library(sp)
```

# Data filtering here

```{r load_all_birds}
#'load all birds
load("knots_data/knots01_data.rdata")
day30 <- as.numeric(as.POSIXct("2017-09-24", tz = "CEST", origin = "1970-01-01"))

for(i in 1:length(k1.data)){
  k1.data[[i]]$id = names(k1.data)[i]
}

#'filter one month
k1.data <- k1.data %>% rbind_list() %>% filter(ts < "2017-09-23")

#'get 1 minute means
k1 <- k1.data %>% mutate(time_round = round_date(ts, "minute")) %>% 
  group_by(id, time_round) %>% 
  summarise_all(funs(mean(., na.rm = T)))

load("knots_data/k1.tides.rdata")

k1.tide <- k1 %>% dlply("id") %>% 
  map(function(x){
    full_join(x, tide, by = c("time_round" = "time")) %>% arrange(time_round) %>% mutate(tide = ifelse(is.na(tide), "other", tide)) %>% mutate(ht = cumsum(tide == "H")+1)
  }) %>% bind_rows() %>% dlply(c("id","ht"))
```

```{r median_filter}
#'get distances and remove unrealistic distances
k1.tide <- k1.tide[unlist(lapply(k1.tide, function(x) sum(!is.na(x$X)))) > 0.3*12*60]

#'apply a 5-point median filter
k1.tide <- map(k1.tide, function(x){
  filter(x, abs(COVXY) < 1e3) %>% 
  mutate(X = runmed(X, 5), Y = runmed(Y, 5))
})

#'remove low data tides
k1.tide <- k1.tide[unlist(lapply(k1.tide, function(x) sum(!is.na(x$X)))) > 0.3*12*60]
```

```{r distances_hist}
for(i in 1:length(k1.tide)){
  a <- k1.tide[[i]]
  a$distance <- c(NA, spDists(x = a[,c("X","Y")], segments = T))
  k1.tide[[i]] <- a
}

#'identify segments as moves over 95th percentile
k1.tide <- k1.tide %>% 
  map(function(x){
    filter(x, !is.na(distance)) %>% mutate(segment = cumsum(distance > 120))
  })

#'split by segment, remove small segments under 5 positions
k1.tide <- k1.tide %>% 
  bind_rows() %>% 
  dlply(c("id","ht","segment"))
k1.tide <- k1.tide[unlist(lapply(k1.tide, nrow)) > 3]
```

```{r}
#'this looks great! but not worth a PSKF right now.
#'save for use with the HF proximity code
k1.tide <- bind_rows(unclass(k1.tide)) %>% dlply(c("id","ht"))

#'note. knots01_short_segs has been saved as the same df, delete it
save(k1.tide, file = "knots_data/knots01_median_filter.rdata")
```

# Tide matching here

```{r prep_for_segments}
#'prep data, remove point with fpt less than 10 mins
#data.prep = data %>% filter(fpt > 10/60) %>% 
#  dlply("id.ht")
load("knots_data/knots01_short_segs.rdata")

#'get dummy data, and time since high tide
data.prep <- k1.tide %>% 
  map(function(x){
    arrange(x, TIME) %>% mutate(ht.time = round(TIME/1e3 - first(TIME/1e3)))
  })

#'remove tracks with less than 60 positions remaining , ie, data.prep with less than 60 positions
#data.prep = data.prep[unlist(map(data.prep, nrow))>= 60]
```

```{r}
#'load tides
load("knots_data/k1.tides.rdata")
#'in each tide get the list of potential times in mins
tide.mins <- tide %>%
  filter(tide == "H") %>% 
  mutate(ht = cumsum(tide == "H")+1,
         time = round_date(time, "minute")) %>% 
  dlply("ht")

#'get minute sequence
for (i in 1:(length(tide.mins)-1)){
  tide.mins[[i]] <- data_frame(time = seq(tide.mins[[i]]$time, tide.mins[[(i+1)]]$time, 60), ht = as.numeric(names(tide.mins)[i]))
}

#'bind rows
tide.mins <- rbind_list(tide.mins)
```

```{r}
#'left bind the tracking data with the expected minutes by tide
data.tide <- data.prep %>% 
  map(function(x){
    x %>% mutate(ht = as.numeric(ht)) %>%
      right_join(tide.mins %>% filter(ht == as.numeric(x$ht)), by = c("time_round"="time","ht"))
  })

#'save this data
save(data.tide, file = "knots_data/knots01_tide_minute_matched.rdata")
```

```{r}
#'load data from here
load("knots_data/knots01_tide_minute_matched.rdata")
```


```{r}
#'assign tide and id to each element of the list
data.tide <- data.tide %>% 
  map(function(x) {x %>% mutate(ht = first(ht[!is.na(ht)]),
      id = first(id[!is.na(id)]))})
```

```{r}
#'bind rows, get the time since high tide, ungroup, assign values in pplace of NAs
data.tide <- rbind_list(data.tide) %>% 
  group_by(ht = as.factor(ht)) %>% 
  mutate(ht.time = as.numeric(time_round) - min(as.numeric(time_round), na.rm = T)) %>% 
  ungroup() %>% 
  mutate(X = ifelse(is.na(X), 9e9,X),                                                                     Y = ifelse(is.na(Y), 9e9,Y)) %>% 
  dlply("ht")

save(data.tide, file = "knots_data/kntoscode023_tidematched_data.rdata")
```

# Select LT +/- 3 hours

```{r}
#'filter for ht.time between 3.5 and 9.5 hours
data.lt <- data.tide %>% 
  map(function(x){
    x <- x %>% filter(round(ht.time) %between% c(3.5*3600,9.5*3600))
  })

#save(data.lt, data.tide, file = "knots_data/knots01_lowtide_data.rdata")
```

```{r}
#'include only tides where 5 birds are present
data.lt <- data.lt[unlist(lapply(data.lt, function(x){length(unique(x$id))})) > 2]
#'this method is simpler than in knotscode019.
proximity <- data_frame()

for(z in 1:length(data.lt)){
#'split again by id
focals <- dlply(data.lt[[z]], "id")  
#'implement method from knotscode019
for(i in 1:length(focals)){
  #'get focals
  #'get the nonfocal birds
  nonfocals <- focals[!names(focals) %in% names(focals)[i]]
  
  #'loop over nonfocals
  for(j in 1:length(nonfocals)){
    distances <- spDists(as.matrix(focals[[i]][,c("X","Y")]), as.matrix(nonfocals[[j]][,c("X","Y")]), diagonal = T)
    #'get only distances where both focal and nonfocal positions are known
    #'set all distances greater than 9e6 = 0, and all rows where focal pos and all cols where nonfocal pos are > 9e6
    distances[focals[[i]]$X > 9e6 | nonfocals[[j]]$Y > 9e6] <- NA
    #distances <- diag(distances)
    interactions <- data_frame(distances = sum(distances <= 200, na.rm = T)) %>%
      #count(class) %>% 
      mutate(focal = unique(focals[[i]]$id), 
             nonfocal = unique(nonfocals[[j]]$id), 
             ht = unique(focals[[i]]$ht), 
             pos_focal = sum(focals[[i]]$X < 9e9), 
             pos_nonfocal = sum(nonfocals[[j]]$X < 9e9))
    proximity <- rbind(proximity, interactions)
    }
  }
}
```

```{r}
#'calculate coherence scores for under 100m
proximity100 <- proximity %>%
  dlply("ht") %>% 
  map(function(x){
    x %>% group_by(focal, nonfocal, ht) %>% 
  summarise(interactions = sum(distances),
            coherence_emp = interactions/(first(pos_focal) + first(pos_nonfocal) - interactions))
})
```

```{r random_coherence_matrix}
#'get the tide wise coherence arrays for randomisation
coherence <- proximity100 %>% 
  bind_rows() %>% 
  select(-interactions) %>% 
  spread(nonfocal, coherence_emp, drop = F) %>% 
  dlply("ht") %>% 
  map(function(x) {
    x %>% select(-ht,-focal) %>% as.matrix()})

#'remove matrices with no data
coherence <- coherence[unlist(lapply(coherence, function(x){sum(!is.na(x))})) != 0]

#'get a 100 simulation mean array for each tide
for(i in 1:length(coherence)){
  rand.holder = array(dim = c(34,34,100))
  a <- coherence[[i]]
  for(j in 1:1e2){
    rand.holder[,,j] <- a[sample.int(nrow(a)), sample.int(ncol(a))]
  }
  coherence[[i]] <- apply(rand.holder, c(1,2), function(x) mean(x, na.rm = T)) %>% 
    as.data.frame() %>% mutate(focal = colnames(a), ht = names(coherence)[i])
  colnames(coherence[[i]]) <- c(colnames(a), "focal", "ht")
}

#'gather
coherence.sim <- coherence %>% 
  map(function(x){
    x %>% gather(nonfocal, coherence_sim, -focal,-ht)
  }) %>% bind_rows()
```

```{r}
#'bind emp and sim scores
coherence.scores <- proximity100 %>% 
  bind_rows() %>% 
  ungroup() %>% 
  mutate(focal = as.character(focal),
         nonfocal = as.character(nonfocal)) %>% 
  left_join(coherence.sim %>% mutate(ht = as.factor(ht))) %>% 
  filter(focal != nonfocal) %>% 
  mutate(diff = coherence_emp - coherence_sim)
```

```{r}
#'run the KS test
coherence.test <- coherence.scores %>% 
  dlply(c("focal","nonfocal")) %>% 
  map(function(x){
    ks.test(x$coherence_emp, x$coherence_sim)
  }) %>% 
  map(function(x){
    bind_cols(unclass(x))
  }) %>% 
  bind_rows() %>% 
  bind_cols(coherence.scores %>% 
              group_by(focal,nonfocal) %>% 
              summarise(mean_coherence_emp = mean(coherence_emp),
                        mean_coherence_sim = mean(coherence_sim),
                        coherence_diff = mean(diff))) %>% 
  select(-data.name,-alternative,-method)
```

```{r}
#'plot and see
coherence.test %>% 
  filter(abs(coherence_diff) < 1) %>% 
  ggplot()+
  geom_tile(aes(x = focal, y = nonfocal, fill = mean_coherence_emp), col = "transparent", lwd = 0.2)+
  #scale_fill_gradient2(low = "red", mid = "white", high = "blue")+
  #scale_alpha_manual(values = c(0.1,1), guide = F)+
  scale_shape_manual(values = c("", "*"), guide = F)
```
