---
chunk_output_type: console
editor_options: 
  chunk_output_type: console
---
```{r}
source("libs.R");library(sp)
```

```{r load_data}
#load data
load("knots_data/knots01_for_residence_segments.rdata")
```

```{r}
#'floor the time to the minute
data <- data %>%
  mutate(timenum = time,
         time = as.POSIXct(time, origin = "1970-01-01"),
         time = round_date(time, unit = "minute"))
```


```{r prep_for_segments}
#'prep data, remove point with fpt less than 10 mins
data.prep = data %>% filter(fpt > 10/60) %>% dlply("id.ht")

#'remove tracks with less than 60 positions remaining , ie, data.prep with less than 60 positions
data.prep = data.prep[unlist(map(data.prep, nrow))>= 60]
```

```{r}
#'in each tide get the list of potential times in mins
tide.mins <- data %>% 
  dlply("ht") %>% 
  map(function(x){
    seq(min(x$time), max(x$time), 60)
  })
```

```{r}
#'left bind the tracking data with the expected minutes by tide
data.tide <- data.prep %>% 
  map(function(x){
    x %>% mutate(timenum = as.numeric(time)) %>% right_join(data_frame(timenum = as.numeric(unlist(tide.mins[names(tide.mins) == x$ht]))))
  })

#'save this data
#save(data.tide, file = "knots_data/knots01_tide_minute_matched.rdata")
```

```{r}
#'assign tide and id to each element of the list
data.tide <- data.tide %>% 
  map(function(x) {x %>% mutate(ht = first(ht[!is.na(ht)]),
      id = first(id[!is.na(id)]))})
```

```{r}
#'bind rows and split by tide
data.tide <- rbind_list(data.tide) %>% 
  #filter(ht == "002") %>% 
  mutate(x = ifelse(is.na(x), 9e9,x),                                                                     y = ifelse(is.na(y), 9e9,y)) %>% 
  dlply("ht")
```

```{r}
#'this method is simpler than in knotscode019.
proximity <- data_frame()

for(z in 1:length(data.tide)){
#'split again by id
focals <- dlply(data.tide[[z]], "id")  
#'implement method from knotscode019
for(i in 1:length(focals)){
  #'get focals
  #'get the nonfocal birds
  nonfocals <- focals[!names(focals) %in% names(focals)[i]]
  
  #'loop over nonfocals
  for(j in 1:length(nonfocals)){
    distances <- spDists(as.matrix(focals[[i]][,c("x","y")]), as.matrix(nonfocals[[j]][,c("x","y")]), diagonal = T)
    #'get only distances where both focal and nonfocal positions are known
    #'set all distances greater than 9e6 = 0, and all rows where focal pos and all cols where nonfocal pos are > 9e6
    distances[focals[[i]]$x > 9e6 | nonfocals[[j]]$x > 9e6] <- NA
    #distances <- diag(distances)
    interactions <- data_frame(distances = sum(distances <= 25, na.rm = T)) %>%
      #count(class) %>% 
      mutate(focal = unique(focals[[i]]$id), 
             nonfocal = unique(nonfocals[[j]]$id), 
             ht = unique(focals[[i]]$ht), 
             pos_focal = sum(focals[[i]]$x < 9e9), 
             pos_nonfocal = sum(nonfocals[[j]]$x < 9e9))
    proximity <- rbind(proximity, interactions)
    }
  }
}
```

```{r}
#'
```


```{r}
#'calculate coherence scores for under 100m
proximity100 <- proximity %>%
  dlply("ht") %>% 
  map(function(x){
    x %>% group_by(focal, nonfocal, ht) %>% 
  summarise(interactions = sum(distances),
            coherence_emp = interactions/(first(pos_focal) + first(pos_nonfocal) - interactions))
})
```

```{r random_coherence_matrix}
#'get the tide wise coherence arrays for randomisation
coherence <- proximity100 %>% 
  bind_rows() %>% 
  select(-interactions) %>% 
  spread(nonfocal, coherence_emp, drop = F) %>% 
  dlply("ht") %>% 
  map(function(x) {
    x %>% select(-ht,-focal) %>% as.matrix()})

#'get a 100 simulation mean array for each tide
for(i in 1:length(coherence)){
  rand.holder = array(dim = c(36,36,100))
  a <- coherence[[i]]
  for(j in 1:1e2){
    rand.holder[,,j] <- a[sample.int(nrow(a)), sample.int(ncol(a))]
  }
  coherence[[i]] <- apply(rand.holder, c(1,2), function(x) mean(x, na.rm = T)) %>% 
    as.data.frame() %>% mutate(focal = colnames(a), ht = names(coherence)[i])
  colnames(coherence[[i]]) <- c(colnames(a), "focal", "ht")
}

#'gather
coherence.sim <- coherence %>% 
  map(function(x){
    x %>% gather(nonfocal, coherence_sim, -focal,-ht)
  }) %>% bind_rows()
```

```{r}
#'bind emp and sim scores
coherence.scores <- proximity100 %>% 
  bind_rows() %>% 
  ungroup() %>% 
  mutate(focal = as.character(focal),
         nonfocal = as.character(nonfocal)) %>% 
  left_join(coherence.sim) %>% 
  filter(focal != nonfocal) %>% 
  mutate(diff = coherence_emp - coherence_sim)
```

```{r}
#'run the KS test
coherence.test <- coherence.scores %>% 
  dlply(c("focal","nonfocal")) %>% 
  map(function(x){
    ks.test(x$coherence_emp, x$coherence_sim)
  }) %>% 
  map(function(x){
    bind_cols(unclass(x))
  }) %>% 
  bind_rows() %>% 
  bind_cols(coherence.scores %>% 
              group_by(focal,nonfocal) %>% 
              summarise(mean_coherence_emp = mean(coherence_emp),
                        mean_coherence_sim = mean(coherence_sim),
                        coherence_diff = mean(diff))) %>% 
  select(-data.name,-alternative,-method)
```

```{r}
#'plot and see
coherence.test %>% 
  filter(abs(coherence_diff) < 1) %>% 
  ggplot()+
  geom_tile(aes(x = focal, y = nonfocal, fill = coherence_diff), col = "transparent", lwd = 0.2)+
  scale_fill_gradient2(low = "red", mid = "white", high = "blue")+
  #scale_alpha_manual(values = c(0.1,1), guide = F)+
  scale_shape_manual(values = c("", "*"), guide = F)
```

```{r}
coherence.test %>% 
  filter(abs(coherence_diff) < 1) %>% 
  count(p.value <= 0.05, coherence_diff > 0)
```

