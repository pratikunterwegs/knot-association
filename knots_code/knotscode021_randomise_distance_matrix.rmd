---
editor_options: 
  chunk_output_type: console
---

```{r load_data}
#'load data
load("knots_data/proximity.matrix.rdata")
#'load theme
source("ggplot.pub_geese.r")
```

```{r source_libs}
#'load libs
source("libs.R");library(stringi)
```

```{r obs_per_id}
#'in a list, with one element per tide, store matrices of segs per id in tide
id.obs = 
  data.segpaths %>% count(id.ht) %>% 
  separate(id.ht, c("id","ht")) %>% 
  mutate(ht = stri_pad(ht, 3, side = "left", pad = "0"))

```

```{r prep_coeherence_df}
#'join id.obs and proxmat2 by id and ht, then variable and ht
prox.df = prox.mat2 %>% left_join(id.obs) %>% left_join(id.obs %>% rename(n2 = n), by = c("variable" = "id","ht"))
```

```{r calculate_coherence}
#'calculate the association index as used in Myers 1983
prox.df = prox.df %>% 
  mutate(index = value/(n+n2-value),
         index = case_when(
           index >= 1 ~ 1,
           is.nan(index) ~ as.double(NA),
           TRUE ~ index
         ))

#'group by id~var pair and average across tides
prox.df = prox.df %>% 
  group_by(id, variable, ht) %>% 
  summarise(index = mean(index, na.rm = T)) %>% 
  mutate(index = case_when(
    is.nan(index) ~ as.double(NA),
    T ~ index
  ))
```

```{r randomise_coherence_matrix}
#'get the coherence matrix
coherence.matrix = spread(prox.df, variable, index) %>% 
  dlply("ht") %>% 
  map(function(x) x %>% dplyr::select(-ht))

ids = coherence.matrix[[1]]$id

#'run loop across coherence matrix
for(i in 1: length(coherence.matrix)){
  coherence.matrix[[i]]$id = NULL
  coherence.matrix[[i]] = as.matrix(coherence.matrix[[i]])
}

#'store the empirical coherence matrix
coherence.matrix.emp = coherence.matrix
```

```{r random_coherence_matrix}
#'randomise the coherence matrix 1000 times
#'create a 100 element array
rand.cmat.array = array(dim = c(dim(coherence.matrix.emp[[1]]), 1e2))

#'for each tide get an array of 100 elements
for (i in 1:length(coherence.matrix)) {
  #'get the coherence matrix in i-th tide
  a = coherence.matrix[[i]]
  #'assign the array to the list element
  coherence.matrix[[i]] = rand.cmat.array
  #'make each array matrix the i-th coherence matrix
  coherence.matrix[[i]][,,] = a
  
  #'get the array again
  b = coherence.matrix[[i]]
  #'for each matrix in the array
  for(j in 1:dim(b)[3]){
    #'get the j-th matrix
  x = b[,,j]
  #'randomise the j-th matrix (this is row randomisation)
  b[,,j] = x[sample.int(nrow(x)),]
  }
  #'get the array mean
  b = apply(b, c(1,2), function(x) mean(x, na.rm = T))
  #'fill the mean random coherence matrix in the list
  coherence.matrix[[i]] = b
}
```

```{r mean_coherence_matrix}
#'convert to usable form
coherence.matrix.rand = coherence.matrix %>% 
  map(function(x) data.frame(cbind(id = ids, x)))

#'set column names
for(i in 1:length(coherence.matrix.rand)){
  colnames(coherence.matrix.rand[[i]]) = c("id",ids)  
}
```

```{r melt_rand_coherence_matrix}
#'melt and add to prox.df to compare
coherence.matrix.rand = coherence.matrix.rand %>% 
  map(function(x) x %>% melt(id.vars = "id"))

#'assign tides
for(i in 1:length(coherence.matrix.rand)){
  coherence.matrix.rand[[i]]$ht = as.character(names(coherence.matrix.rand))[i]
}

#'bind rows
coherence.rand.df = bind_rows(coherence.matrix.rand)
```

```{r}
#'save value
save(coherence.rand.df, prox.df, file = "knots_data/coherence_test_data.rdata")
```

