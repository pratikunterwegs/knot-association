---
chunk_output_type: console
---
```{r}
#'source libs
source("libs.R")
library(readr);library(stringi)
```

```{r}
#'read in segmented data
load("knots_data/knots01_segmented.rdata")
```

```{r}
#'identify segments where the median position of the next segment is less than 250m away, and assign a new segment number.
#'there has to be a temporal component to this. if a segment's median is > 5mins from the prev segment median, AND if the proximity criterion is satisfied, count a new segments

for(i in 1:length(data.segpaths)){
  a = data.segpaths[[i]]
  a = a %>% 
    group_by(state) %>% 
    summarise(x.med = median(x), y.med = median(y), time.med = median(time)) %>% 
    mutate(time.diff = c(0, diff(time.med)))
  
  b = as.matrix(dist(as.matrix(a[,c("x.med","y.med")])))
  b = b[row(b) - col(b) == 1]
  c = c(0, b)
  a$dist = c
  a$new.seg = cumsum(c > 250 & a$time.diff/60 > 5)+1
  data.segpaths[[i]] = data.segpaths[[i]] %>% 
    left_join(a, by = "state")
}

#'see example: 151.003 is reclassified into 6 segments instead of 8
x = data.segpaths[[1]]; count(x, new.seg)

library(ggplot2)
#'plot example
x %>% select(x,y,state,new.seg) %>% 
  melt(id.vars = c("x","y")) %>% 
  ggplot()+
  geom_point(aes(x = x, y = y, col = as.factor(value)), size = 4)+
  scale_color_brewer(palette = "Set1")+
  facet_wrap(~variable, ncol = 1)
```

```{r}
#'summarise data for distance matrix between the segments
data.segpaths = data.segpaths %>% 
  bind_rows() %>% 
  group_by(id.ht, new.seg) %>% 
  summarise(x.med = median(x),
            y.med = median(y),
            seg.dur = max(time) - min(time),
            time.med = median(time))
```

```{r}
#'get a list with one list per high tide: each row a foraging segment, two columns for coordinates, and one matrix per id
data.list = data.segpaths %>% 
  mutate(ht = stri_pad(substr(as.character(id.ht), 5,7), side = "right", width = 3, pad = "0"),
         id = substr(as.character(id.ht), 1, 3)) %>% 
  dlply("ht") %>% 
  map(function(x){
    x %>% 
      dlply("id")
  })
```

```{r create_holding_list}
#'write this description later
#'in each segment of each focal bird, how many segments of the other bird(s) was(ere) within 250m and within half the segment duration?

#'test run, get only three dfs
#'full run, get all dfs

library(sp)

n.birds = 41

#'make a list of lists, each element of the list is a single tide
proximity.list = vector("list", length(data.list)) %>% 
  map(function(x) {vector("list", n.birds) %>% 
      map(vector("list", n.birds-1))})
```

```{r make_prox_data}
#'write a description here

#'loop over the high tides
for(ht in 1:length(data.list)){
  #'get a manageable name for the i-th HT
  a = data.list[[ht]]

#'loop over the birds present in the HT
for(i in 1:length(a)){
  #'get a list of non-focal birds, ie, other than the focal bird
  b = a[!names(a) %in% names(a)[i]]
  #'loop over all non-focal birds. the max can be 37, as we have 38 knots in batch 1
  for(j in 1:length(b)){
    #'get 2 matrices of median coordinates of the segments, one each for the focal bird a[i]
    #'and the j-th non-focal bird b[j]
    f1 = as.matrix(a[[i]][,c("x.med","y.med")])
    f2 = as.matrix(b[[j]][,c("x.med","y.med")])
    
    #'calculate the distance matrix, all points to all points
    dist.matrix = spDists(x = f1, y = f2)
    
    #'get the time difference between the median timestamp of each segment
    #'i think of this as the temporal matrix, how close in time each segment
    #'of focal and non-focal bird are
    time.matrix = outer(a[[i]]$time.med, b[[j]]$time.med, FUN = "-")
    
    #'get a matrix which holds TRUE/FALSE values for whether the temporal difference between
    #'focal and non-focal segment was less than half the duration of the focal segment.
    #'this might cover cases where a leader-follower dynamic exists over a range longer than the
    #'distance used for physical proximity. think of it as a moving flock where one bird is more
    #'than x-m behind the other, but reaches the same point because they're associated in the flock.
    #'this draws from flock or roost based analyses from the Myers 1983 and Colwell-Conklin 2007 papers
    temp.prox = apply(time.matrix, 2, function(x) abs(x) <= a[[i]]$seg.dur/2)
    
    #'if the distance between 2 segments is too great in EITHER space OR time, assign an NA
    dist.matrix[temp.prox == F | dist.matrix >= 200] = NA
    
    #'find the sum of events in which the focal and non-focal birds were BOTH temporally
    #'AND spatially proximate
    seg.prox.count = apply(dist.matrix, 1, function(x) sum(!is.na(x)))
    
    #'assign this vector to its position in a 3-level list
    proximity.list[[ht]][[i]][[j]] = seg.prox.count
    
  }
  #'assign names to level 3 of the list, the name is the id of the non-focal bird
  names(proximity.list[[ht]][[i]]) = names(b)
  #'collapse the third level of lists into a df, the second level is the id of the focal bird
  proximity.list[[ht]][[i]] = proximity.list[[ht]][[i]] %>% bind_rows() %>% 
    mutate(id = names(a)[i],
           seg = 1:length(id),
           ht = names(data.list)[ht]) %>% 
    melt(id.vars = c("id","seg","ht"))
  #'assign names to level 2, these are focal bird ids
  names(proximity.list[[ht]]) = names(a)
  }
}

#'set ht names, this is the top level of the list
names(proximity.list) = names(data.list)
```

```{r}
#'now bind within ht to get a unified df
proximity.list = proximity.list %>% 
  map(bind_rows) %>% 
  bind_rows()
```

```{r}
#'remove the segment id and grouping by focal, HT and non-focal, count the number of interactions, assigning NA where there is both no data and where no interactions occurred. this is dealt with in the next
prox.mat = proximity.list %>% 
  select(-seg) %>% 
  group_by(id, ht, variable) %>% 
  summarise(value = sum(value)) %>% 
  spread(variable, value, drop = F)
 
```

```{r}
#'0 or NA? real absence or non-detection?
#'remake the long form of the matrix, then check if the proxmity value is NA, then check if the nonfocal bird is present in the segmented paths, then assign the value, 0, or NA, remove the nonfocal column, spread the data by var, value, then split the df by high tide, then remove the ht id

prox.mat2 = melt(prox.mat, id.vars = c("id","ht")) %>% 
  mutate(nonfocal = paste(variable, ht, sep= "."),
         variable = as.character(variable),
         value = as.double(value),
         value = case_when(
           !is.na(value) ~ value,
           variable == id ~ as.double(NA),
           nonfocal %in% data.segpaths$id.ht ~ 0,
           T ~ as.double(NA))) %>% 
  select(-nonfocal) #%>% 
  #spread(variable, value) %>% 
  #dlply("ht") %>% 
  #map(function(x) x %>% select(-ht))
```

```{r}
save(prox.mat2, data.segpaths, file = "knots_data/proximity.matrix.rdata")
```

