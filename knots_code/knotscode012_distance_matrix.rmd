```{r}
#### data for array based pairwise distances
source("libs.R")
library(readr)

load("knots_data/foraging_segments.rdata")
```

```{r assign_timestamps}
#'split into lsit, and then merge each element to the timestamps df.
segment.list = data.segmented %>% 
  filter(seg == 1) %>% 
  dlply(c("id.ht","seg"))

#this needs a for loop
for(i in 1:length(segment.list)){
  x = segment.list[[i]]
  x.id.ht = unique(x$id.ht)
  x.time.range = range(x$time)
  x = x %>% 
    bind_rows(data.segmented %>% 
                filter(id.ht != x.id.ht,
                       time %between% c(x.time.range))) %>% 
    dlply("id.ht") %>% 
    map(function(x){
      x %>% select(x,y)
    }) %>% 
    map(as.matrix)
  x = abind::abind(x, along = 3)
  segment.list[[i]] = x
}

```

```{r}
#'now run the spdists functions through a for loop
#'load libs
library(geosphere)

d = array(dim = c(nrow(k2.time), length(a)-1, length(a)))
id.array = array(dim = c(nrow(k2.time), 5, length(a)))

for (i in 1:length(a)) {
  x = a[!names(a) %in% names(a)[i]]
  for(j in 1:length(x)){
    d[,j,i] = (distVincentyEllipsoid(p1 = a[[i]], p2 = x[[j]]))
  }
  e = d[,,i]
  z = apply(e, c(1), function(y){which(y %in% head(sort(y), 5))})
  #z2 = which(unlist(lapply(z, length)) < 5)

  for (k in 1:length(z)) {
    z[[k]] = c(z[[k]], rep(NA, 5 - length(z[[k]])))
    id.array[k,,i] = names(x)[z[[k]]]
  }

}

#'make each matrix of each array a df
e = d %>% apply(3, data.frame)

id.array = id.array %>% apply(3, data.frame)

#'assign names
names(e) = names(id.array) = names(a)

```

```{r set_colnames}
#'set colnames as the ids of the knots other than the focal knot
for (i in 1:length(e)) {
  colnames(e[[i]]) = names(e[!names(e) %in% names(e)[i]])
}

save(e, id.array, file = "knots_data/distance_matrix.rdata")
```
