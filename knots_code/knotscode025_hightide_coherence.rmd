---
output: html_document
editor_options: 
  chunk_output_type: console
---
```{r}
source("libs.R");library(sp)
load("knots_data/kntoscode023_tidematched_data.rdata")
library(stringi)
#'get ht data
data <- unclass(data.tide) %>% 
  bind_rows() %>% 
  #anti_join(unclass(data.lt) %>% bind_rows()) %>% 
  mutate(hour = stri_pad(round_any(ht.time/3600, 1), width = 2, pad = "0"),
         ht = stri_pad(ht, width = 2, pad = "0"))

#'assign a tidal interval
data <- data %>% 
 # map(function(x){
 #   mutate(x, tide = ifelse(is.na(tide),"other",tide),
 #          lt = cumsum(tide == "L")+1) %>% 
 #     filter(tide != "L")
 #}) %>% unclass() %>% bind_rows() %>% 
  dlply(c("ht"))

#'remove tides with < 3 birds
data <- data[unlist(lapply(data, function(x) length(unique(x$id[!is.na(x$id)])))) > 2]
```

```{r}
library(sp)
#'this method is simpler than in knotscode019.
proximity <- data_frame()

for(z in 1:length(data)){
#'split again by id
focals <- dlply(data[[z]], "id")  
#'implement method from knotscode019
for(i in 1:length(focals)){
  #'get focals
  #'get the nonfocal birds
  nonfocals <- focals[!names(focals) %in% names(focals)[i]]
  
  #'loop over nonfocals
  for(j in 1:length(nonfocals)){
    distances <- spDists(as.matrix(focals[[i]][,c("X","Y")]), as.matrix(nonfocals[[j]][,c("X","Y")]), diagonal = T)
    #'get only distances where both focal and nonfocal positions are known
    #'set all distances greater than 9e6 = 0, and all rows where focal pos and all cols where nonfocal pos are > 9e6
    distances[focals[[i]]$X > 9e6 | nonfocals[[j]]$Y > 9e6] <- NA
    #distances <- diag(distances)
    interactions <- data_frame(distances = sum(distances <= 100, na.rm = T)) %>%
      #count(class) %>% 
      mutate(focal = unique(focals[[i]]$id), 
             nonfocal = unique(nonfocals[[j]]$id), 
             ht = unique(focals[[i]]$ht),
             pos_focal = sum(focals[[i]]$X < 9e9), 
             pos_nonfocal = sum(nonfocals[[j]]$X < 9e9))
    proximity <- rbind(proximity, interactions)
    }
  }
}
```

```{r}
#'which pairs are proximate (<= 100m) for 0.25 or more of positions, at <= 3 hours after high tide
#'what proportion of pairwise positions are under 100m between 0 and 3 hours after high tide, and which pairs have a proportion of 0.25 or more?

proximate.pairs <- filter(proximity, focal < nonfocal, as.numeric(ht.hr) <=5, pos_focal > 10, pos_nonfocal > 10) %>% group_by(focal, nonfocal) %>% summarise(prop.proximity = mean(distances/pos_focal)) %>% filter(prop.proximity >= 0.25) %>% ungroup() %>% mutate(pair = 1:nrow(.))
```


```{r}
#'calculate coherence scores for under 100m
proximity100 <- proximity %>%
  dlply(c("ht")) %>% 
  map(function(x){
    x %>% group_by(focal, nonfocal, ht) %>% 
  summarise(pos_focal = first(pos_focal),
            pos_nonfocal = first(pos_nonfocal),
    interactions = sum(distances),
            coherence_emp = case_when(
    pos_focal == 0 & pos_nonfocal == 0 ~ as.double(NA),
    T ~ interactions/(first(pos_focal))))
})
```

```{r what_explains_coherence}
#'get coherence n-1, remove pairs with less than 3 tides of presence
cij <- group_by(cij, focal, nonfocal) %>% 
  mutate(n = length(interactions)) %>% 
  filter(n > 2) %>% 
  mutate(cn1 = c(NA, coherence_emp[2:length(coherence_emp)]),
         hour = as.numeric(hour)) %>% 
  left_join(data.summary, by = c("focal" = "id","ht","hour"))

#'only consider rows with 10+ positions focal and nonfocal
cij <- filter(cij, pos_focal >= 10, pos_nonfocal >= 10)
```

```{r}
#'get unique pairs
pairs <- expand(ungroup(cij), focal, nonfocal) %>% filter(focal < nonfocal) %>% ungroup() %>% mutate(pair = 1:nrow(.))

cij <- left_join(cij, pairs) %>% filter(!is.na(pair))
```

```{r}
cairo_ps(filename = "figure_coherence_hour.eps", width = 200/25.4, height = 200/25.4)

cij %>% 
  ggplot()+
  geom_jitter(aes(x = hour, y = coherence_emp), col = "grey80", shape = 1)+
  geom_smooth(aes(x = hour, y = coherence_emp*3), fill = cola1, size = 2)+
  scale_y_continuous(sec.axis = sec_axis(~.*(1/3), name = "Mean pairwise coherence"))+
  scale_x_continuous(breaks = c(0,7,13), labels = c("High tide","Low tide","High tide"))+
  #scale_colour_viridis_d(guide = F)+
  labs(list(x = "Hours post high tide", y = "Pairwise coherence"))+
  theme_pub()+
  theme(axis.text = element_text(size = 16), axis.title = element_text(size = 20))

dev.off()
```


```{r}
#'model for coherence consistency
library(glmmTMB)
cij$pair = as.factor(cij$pair)
#'run zero inflated glmm for coherence consistency
mod.coherence.consistency = glmmTMB(coherence_emp ~ cn1 + sqrt(hour) + (1|pair) + (1|ht), data = cij, family = binomial, ziformula = ~1)
```

```{r}
#'coherence consistency in close pairs
cij.prox <- inner_join(cij %>% select(-pair), proximate.pairs)

mod.c.cons.prox = glmmTMB(coherence_emp ~ cn1 + log(dist.mismatch) + sqrt(hour) + (1|ht), data = cij, family = binomial, ziformula = ~coherence_emp)
```

```{r}
#'advancing - receding coherence
cij.state <- filter(cij, !hour %between% c(4:8)) %>% mutate(state = ifelse(hour < 4, "receding","advancing")) %>% group_by(pair, state, ht) %>% summarise(c = mean(coherence_emp)) %>% spread(state, c)

#'handle factors
cij.state <- cij.state %>% filter(!is.na(advancing), !is.na(receding)) %>% 
  left_join(cij %>% group_by(pair, ht) %>% summarise(dist.m = sum(dist.mismatch), speed.m = mean(speed.mismatch, na.rm = T)))

mod.c.cons.state <- glmmTMB(advancing ~ receding * log(speed.m) + (1|pair)+(1|ht), data = cij.state, family = binomial, ziformula = ~1)
```


```{r rand_cohere_matriz}
#'get the tide wise coherence arrays for randomisation
coherence <- proximity100 %>% 
  bind_rows() %>% 
  group_by(focal, nonfocal,ht) %>% 
  summarise(coherence_emp = mean(coherence_emp, na.rm = T)) %>% 
  spread(nonfocal, coherence_emp, drop = F) %>% 
  dlply(c("ht")) %>%
  map(function(x) {
    x %>% select(-focal,-ht) %>% as.matrix()})

#'get a 100 simulation mean array for each tide
for(i in 1:length(coherence)){
  rand.holder = array(dim = c(34,34,100))
  a <- coherence[[i]]
  for(j in 1:1e2){
    rand.holder[,,j] <- a[sample.int(nrow(a)),sample.int(ncol(a))]
  }
  coherence[[i]] <- apply(rand.holder, c(1,2), function(x) mean(x, na.rm = T)) %>% 
    as.data.frame() %>% mutate(focal = colnames(a), ht = names(coherence)[i])
  colnames(coherence[[i]]) <- c(colnames(a), "focal", "ht")
}

#'gather
coherence.sim <- coherence %>% 
  map(function(x){
    x %>% gather(nonfocal, coherence_sim, -focal,-ht)
  }) %>% bind_rows()
```

```{r}
#'bind emp and sim scores
coherence.scores <- proximity100 %>% 
  bind_rows() %>% 
  group_by(focal, nonfocal, ht) %>% 
  summarise(coherence_emp = mean(coherence_emp, na.rm = T)) %>% 
  ungroup() %>% 
  mutate(focal = as.character(focal),
         nonfocal = as.character(nonfocal)) %>% 
  left_join(coherence.sim)

#'retain only unique pairs
coherence.scores <- coherence.scores %>% filter(focal < nonfocal)
```

```{r}
#'run the KS test
coherence.test <- coherence.test %>% 
  dlply(c("focal","nonfocal")) %>% 
  map(function(x){
    ks.test(x = x$coherence_emp, y = x$coherence_sim, exact = F)
  }) %>% 
  map(function(x){
    bind_cols(unclass(x))
  }) %>% 
  bind_rows() %>% 
  bind_cols(coherence.test %>%
              summarise(mean_coherence_emp = mean(coherence_emp),
                        mean_coherence_sim = mean(coherence_sim),
                        coherence_diff = mean(diff))) %>% 
  select(-data.name,-alternative,-method)
```

```{r}
cairo_ps(filename = "figure_coherence_test.eps", width = 200/25.4, height = 200/25.4)

#'plot
coherence.test %>% 
  #filter(abs(coherence_diff) < 1) %>% 
  ggplot()+
  geom_tile(aes(x = focal, y = nonfocal, fill = mean_coherence_emp*1e2, alpha = p.value<=0.05), col = "white", lwd = 0.2)+
  scale_fill_viridis_c(option = "plasma")+
  #scale_alpha_continuous()+
  scale_alpha_manual(values = c(0.4,1), guide = F)+
  #scale_shape_manual(values = c("", "*"), guide = F)+
    theme_bw()+
  coord_flip()+
  theme(legend.position = "top",panel.border = element_blank(), axis.ticks.length = unit(2,"mm"), axis.text.x = element_text(angle = 30), axis.title = element_text(size = 20), legend.title = element_text(size = 20))+
  labs(list(x = "Knot id",y ="Knot id", fill = "Coherence %"))

dev.off()
```

```{r}
cairo_ps(filename = "coherence_distribution.eps", width = 200/25.4, height = 200/25.4, fallback_resolution = 600)

coherence.test %>% 
  melt(measure.vars = c("mean_coherence_emp","mean_coherence_sim")) %>% 
  ggplot()+
  geom_histogram(aes(x = value*1e2, fill = rev(variable)), alpha = 0.8, bins = 30, position = "identity")+
  coord_cartesian(xlim =c(0,30), expand = F)+
  theme_pub()+
  scale_fill_economist(labels = c("Simulated","Empirical"))+
  theme(legend.position ="top", axis.title = element_text(size = 20), legend.title = element_text(size = 20), legend.text = element_text(size = 15), axis.text = element_text(size = 12))+
  #facet_wrap(~variable)
  labs(list(x = "Coherence %", y = "Density", fill = "Coherence"))

dev.off()
```

```{r}
cairo_ps(filename = "coherence_test_prop.eps", width = 200/25.4, height = 200/25.4, fallback_resolution = 600)

#'get plot of coherence positive or negative
coherence.test %>% mutate(cdiff = mean_coherence_emp - mean_coherence_sim) %>% filter(!is.na(cdiff)) %>% 
  count(p = p.value <= 0.05, friends = cdiff >0) %>% 
  mutate(prop = n/sum(n)) %>% 
  
  ggplot()+
  geom_tile(aes(x = friends, y = p, fill = prop))+
  geom_text(aes(x = friends, y = p, label = paste(round(prop*100), "%")), col = c(1,1,1,"white"), size = 12)+
  scale_fill_viridis(option = "plasma", guide = F)+
  theme_bw()+theme(legend.position ="top", axis.title = element_text(size = 20), legend.title = element_text(size = 20), legend.text = element_text(size = 10, angle = 30), axis.text = element_text(size = 12))+
  labs(list(x = "Coherence", y = "P-value â‰¤ 0.05"))

dev.off()
```

