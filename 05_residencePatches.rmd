---
editor_options: 
  chunk_output_type: console
---

# Residence patch construction

This section is about using the main `watlasUtils` functions to infer residence points when data is missing from a movement track, to classify points into residence or travelling, and to construct low-tide residence patches from the residence points. Summary statistics on these spatial outputs are then exported to file for further use.

**Workflow**

1. Prepare `watlasUtils` and required libraries,
2. Read data, infer residence, classify points, construct low-tide patches, and get spatial data from patches,
3. Get patch trajectories,
4. Export spatial data.

## Prepare libraries

```{r prep_libs, message=FALSE, warning=FALSE}
# load watlasUtils or install if not available
if("watlasUtils" %in% installed.packages() == FALSE){
  devtools::install_github("pratikunterwegs/watlasUtils")
}
library(watlasUtils)

# libraries to process data
library(data.table)
library(purrr)
library(stringr)
library(glue)
library(readr)
library(dplyr)
library(fasttime)

# functions for this stage alone
ci <- function(x){qnorm(0.975)*sd(x, na.rm = T)/sqrt((length(x)))}
```

## Patch construction

```{r remove_old_data, eval=FALSE}
if(file.exists("data/data2018/tidal_mean_speed_2018.csv")){
  file.remove("data/data2018/tidal_mean_speed_2018.csv")
}

if(file.exists("data/data2018/data_patch_summary.csv")){
  file.remove("data/data2018/data_patch_summary.csv")
}
```

Process patches. Takes approx. 5 hours for 3 second data.

```{r make_patches, eval=FALSE, message=FALSE, warning=FALSE}
# make a list of data files to read
data_files <- list.files(path = "data/data2018/revisitData", pattern = "_revisit.csv", full.names = TRUE)

# map inferResidence, classifyPath, and getPatches over data

for(i in 1:length(data_files)){
  df = data_files[i]
  
  success = FALSE
  {
    temp_data <- fread(df)
    temp_data[,ts:=fastPOSIXct(ts)]
    
    id <- unique(temp_data$id)
    tide_number <- unique(temp_data$tide_number)
    
    # get data summary
    {
      data_summary <- temp_data[,.(duration = (max(time) - min(time))/60,
                                   n_fixes = length(x),
                                   prop_fixes = length(x) / ((max(time) - min(time))/30)),
                                by = .(id, tide_number)]
      
      sld <- watlasUtils::wat_simple_dist(temp_data, "x", "y")
      timelag <- c(NA, as.numeric(diff(temp_data$time)))
      speed <- sld/timelag
      
      data_summary[,`:=`(mean_speed = mean(speed, na.rm=TRUE),
                         ci95_speed = ci(speed))]
      
      # write data
      fwrite(data_summary, file = "data/data2018/tidal_mean_speed_2018.csv", 
             append = TRUE, scipen = 6)
    }
    
    # wrap process in try catch
    tryCatch(
      {
        # watlasUtils function to infer residence
        temp_data <- wat_infer_residence(df = temp_data,
                                         infResTime = 2,
                                         infPatchTimeDiff = 30,
                                         infPatchSpatDiff = 100)
        
        # watlasUtils function to classify path
        temp_data <- wat_classify_points(somedata = temp_data,
                                         resTimeLimit = 2)
        
        # watlasUtils function to get patches
        patch_data <- wat_make_res_patch(somedata = temp_data,
                                         bufferSize = 10,
                                         spatIndepLim = 100,
                                         tempIndepLim = 30,
                                         restIndepLim = 30,
                                         minFixes = 3,
                                         tideLims = c(3,10))
        
        # watlasUtils function to get patch data as spatial
        patch_summary <- wat_get_patch_summary(resPatchData = patch_data,
                                               dataColumn = "data",
                                               whichData = "summary")
        
        # print message
        message(as.character(glue('patches {id}_{tide_number} done')))
        
        success = TRUE
      },
      # null error function, with option to collect data on errors
      error= function(e)
      {
        message(glue::glue('patches {id}_{tide_number} errored'))
      }
      
    )
  }
  
  # write patch summary data
  if(success == TRUE){
    fwrite(patch_summary, file = "data/watlas_2018/data_patch_summaries.csv",
           append = TRUE)
  }
  
})

```

## Get patch trajectories

```{r patch_trajectories, eval=FALSE, message=FALSE, warning=FALSE}
# save as temp data
save(output_data, file = "data/data2018/patch_data_2018.rdata")
# filter non-sf objects from the list
output_data <- keep(output_data, function(obj){"data.frame" %in% class(obj)})
output_data <- bind_rows(output_data)

fwrite(output_data, file = "data/data2018/patch_summary.csv",
       dateTimeAs = "ISO")
```

