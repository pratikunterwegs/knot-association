---
editor_options: 
  chunk_output_type: console
---

# Finding networks in tidal cycles

## Read in patch data and overlaps

```{r}
# to handle data
library(readr)
library(scales)
library(tidyr); library(tibble)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)

# to work with networks
library(igraph)
library(rptR)

# to plot
library(ggplot2)
library(scico)
```

```{r}
# read in patch data
data_patches <- read_csv("data/data2018/data_2018_patch_summary_has_patches.csv") %>% 
  mutate(uid = as.character(1:nrow(.)))
# read in overlap data
data <- read_csv("data/data2018/data_spatio_temporal_overlap_2018.csv")
```

## Identify communities of residence patches

### Make unweighted network from overlaps

```{r}
# prepare edgelist
data_edges <- select(data, contains("patch"))

# prepare network from edgelist
network_overlap <- igraph::graph_from_data_frame(d = data_edges, directed = F)
```

### Find communities

```{r}
# get communities using fastgreedy
# the network is unweighted
data_communities <- igraph::fastgreedy.community(network_overlap)
d <- communities(data_communities) %>% 
  imap(function(.x, .id){
    tibble(flock = .id,
           patch = .x)
  })

# get data as a tibble
flock_id <- bind_rows(d)
```

### Join flock data to edgelist

```{r}
# join flock and patch by uid on the first patch
data <- data %>% 
  mutate_at(vars(matches("patch")),
            as.character) %>% 
  left_join(flock_id,
            by = c("patch_i_unique_id" = "patch"))

# join patch data, basically id data, to flock data
tmp_patches <- filter(data_patches,
                      uid %in% flock_id$patch) %>% 
  select(id, uid)
data <- left_join(data, tmp_patches,
                  by = c("patch_i_unique_id" = "uid")) %>% 
  left_join(tmp_patches,
            by = c("patch_j_unique_id" = "uid"))

# get id and weights
edges_df <- select(data,
               matches("(id.)|flock")) %>% 
  rename(id_x = id.x, id_y = id.y) %>% 
  filter(id_x != id_y)
```

## Prepare network data

### Prepare subset-wise edgelist

Here, the subsets are the tide number and tidal stage. The edge-list indicates pairwise overlap.

```{r}
# group and nest
edges_df <- group_by(edges_df, 
                     flock) %>% 
  nest()

# count flock edges and remove small flocks
# ie, with fewer than 3 edges
edges_df <- mutate(edges_df,
                   n_edges = map_int(data, nrow)) %>% 
  filter(n_edges > 3)
```

### Get individual data

```{r}
# make nodes data -- this the individual identities
# add individual data to patch data
data_id <- readxl::read_excel("data/data2018/Biometrics_2018-2019.xlsx") %>% 
  filter(str_detect(`TAG NR`, "[a-zA-Z]+", negate = TRUE))

# a function for gizzard mass
get_gizzard_mass <- function(x, y) {-1.09 + (3.78*(x*y))}

# add gizzard mass
data_id <- mutate(data_id,
                  gizzard_mass = get_gizzard_mass(SH1, SW1))

# rename columns and drop ids without mass and gizzard mass
data_id <- data_id %>% 
  select(id = `TAG NR`, 
         wing = WING, mass = MASS, 
         gizzard_mass) %>% 
  distinct(id, .keep_all = TRUE) %>% 
  drop_na(gizzard_mass)

# add some exploration scores and tag info
data_behav <- read_csv("data/data2018/2018-19-all_exploration_scores.csv") %>% 
  filter(Exp == "F01")
data_tag <- read_csv("data/data2018/tag_info.csv") %>% 
  mutate(id = as.character(Toa_Tag))

# join all scores
data_id <- left_join(data_id, data_tag,
                     by = c("id")) %>% 
  left_join(data_behav, by = "FB")

# remove ids with no exploration
data_id <- mutate(data_id,
                  behav = Mean) %>% 
  # drop_na(behav) %>% 
  select(id, mass, gizzard_mass, behav)
```

### Prepare nodes data

```{r}
# expand nodes df to match edges data
nodes_df <-  
  summarise(edges_df, 
            id = map(data, 
                     function(df) {union(df$id_x, df$id_y)})) %>%
  mutate(id = map(id, function(df){
    
    df <- tibble(id = as.character(df)) %>% 
      left_join(data_id, by = "id")
    
    # remove nodes with no attributes
    df <- drop_na(df, gizzard_mass)
  }))
```

This data needs to be converted to `igraph` networks.

## Flock identity as random effect

### Prepare flock data

```{r}
# filter for existing node data
nodes_df <- filter(nodes_df,
                   map_lgl(id, function(df){nrow(df)>1}))

# unnest flock id
flock_data <- unnest(nodes_df,
                     cols = "id")

# add flock data to patch data
data_patches <- left_join(data_patches,
                          flock_id,
                          by = c("uid" = "patch"))

# separate by tidal stage, where waterlevel < 55 is low tide
data_flock_attrs <- select(data_patches,
                           uid,
                           matches("(x|y|waterlevel)(_mean)"),
                           flock) %>% 
  filter(uid %in% flock_id$patch) %>% 
  group_by(flock) %>% 
  summarise_at(vars(contains("mean")),
               .funs = mean)

# add waterlevel to flock
flock_data <- left_join(flock_data,
                        data_flock_attrs,
                        by = "flock")
flock_data <- mutate(flock_data,
                     tide_stage = if_else(waterlevel_mean < 55, "low", "high"))
```

### Run `rptr` model

```{r}
# run repeat-r model
model_flock <- rptGaussian(behav ~ tide_stage + (1|flock) + (1|id), 
                           grname = c("flock", "Fixed"),
                           data = flock_data)
```

