---
editor_options: 
  chunk_output_type: console
---

# Finding networks from patch data

**Workflow:**

1. Read in patch data, and link to individual trait data.
2. Remove individuals with traits within 1 SD of the population mean,
and their patches.
3. Find communities in the remaining patches.
4. Filter communities for data quality, and calculate assortativity.
5. Relate assortativity to flock attributes:
  - waterlevel start
  - flock size

## Read in patch data and overlaps

```{r}
# to handle data
library(readr)
library(scales)
library(tidyr); library(tibble)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)

# to work with networks
library(igraph)

# to plot
library(ggplot2)
library(scico)
```

```{r}
# read in patch data
data_patches <- read_csv("data/data2018/data_2018_patch_summary_has_patches.csv") %>% 
  mutate(uid = as.character(1:nrow(.)))
# read in overlap data
data <- read_csv("data/data2018/data_spatio_temporal_overlap_2018.csv")
```

## Retain extreme individuals

### Read in trait data

```{r}
# make nodes data -- this the individual identities
# add individual data to patch data
data_id <- readxl::read_excel("data/data2018/Biometrics_2018-2019.xlsx") %>% 
  filter(str_detect(`TAG NR`, "[a-zA-Z]+", negate = TRUE))

# a function for gizzard mass
get_gizzard_mass <- function(x, y) {-1.09 + (3.78*(x*y))}

# add gizzard mass
data_id <- mutate(data_id,
                  gizzard_mass = get_gizzard_mass(SH1, SW1))

# rename columns and drop ids without mass and gizzard mass
data_id <- data_id %>% 
  select(id = `TAG NR`, 
         wing = WING, mass = MASS, 
         gizzard_mass) %>% 
  distinct(id, .keep_all = TRUE) %>% 
  drop_na(gizzard_mass)

# add some exploration scores and tag info
data_behav <- read_csv("data/data2018/2018-19-all_exploration_scores.csv") %>% 
  filter(Exp == "F01")
data_tag <- read_csv("data/data2018/tag_info.csv") %>% 
  mutate(id = as.character(Toa_Tag))

# join all scores
data_id <- left_join(data_id, data_tag,
                     by = c("id")) %>% 
  left_join(data_behav, by = "FB")

# remove ids with no exploration
data_id <- mutate(data_id,
                  behav = Mean) %>% 
  # drop_na(behav) %>% 
  select(id, mass, gizzard_mass, behav)
```

### Plot histogram of traits

Plot trait distribution, median, and SD.

```{r}
# melt data
data_id_long <- pivot_longer(data_id, cols = -id, names_to = "trait")
data_trait_summary <- data_id_long %>% 
  drop_na() %>% 
  group_by(trait) %>% 
  summarise_at(vars(value), .funs = list(median = median, sd = sd))

# plot data
ggplot(data_id_long)+
  geom_histogram(aes(value),
                 fill = "grey")+
  geom_vline(data = data_trait_summary,
             aes(xintercept = median))+
  
  geom_vline(data = data_trait_summary,
             aes(xintercept = median - sd),
             lty = 2)+
  
  geom_vline(data = data_trait_summary,
             aes(xintercept = median + sd),
             lty = 2)+
  facet_wrap(~trait, scales = "free",
             switch = "x")+
  theme_bw()

ggsave(filename = "figs/fig_trait_distr.png", dpi = 300)
```

### Keep only extreme individuals

Remove individuals with gizzard mass within the median +/- SD value.

```{r}
# get median and SD
median_gm <- filter(data_trait_summary,
                    trait == "gizzard_mass") %>% .$median
sd_gm <- filter(data_trait_summary,
                    trait == "gizzard_mass") %>% .$sd

# filter ids
data_id <- filter(data_id,
                  gizzard_mass > median_gm + sd_gm)
                 # !between(gizzard_mass, median_gm - sd_gm, median_gm + sd_gm))
```

### Keep only extreme individuals' patches

```{r}
data_patches <- filter(data_patches,
                       id %in% data_id$id)
```

### Remove patches with low fixes

Each fix corresponds to 30s time.

```{r}
data_patches <- filter(data_patches,
                       nfixes > 3)
```


### Keep only extreme ids' edges

```{r}
data <- data %>% 
  filter(patch_i_unique_id %in% data_patches$uid,
         patch_j_unique_id %in% data_patches$uid)
```

## Network construction

### Make **unweighted** network from overlaps

```{r}
# prepare edgelist
data_edges <- select(data, contains("patch"))

# prepare network from edgelist
network_overlap <- igraph::graph_from_data_frame(d = data_edges, directed = F)
```

### Find communities

```{r}
# get communities using fastgreedy
# the network is unweighted
data_communities <- igraph::fastgreedy.community(network_overlap)
d <- communities(data_communities) %>% 
  imap(function(.x, .id){
    tibble(flock = .id,
           patch = .x)
  })

# get data as a tibble
flock_id <- bind_rows(d)
```

### Join flock data to edgelist

```{r}
# join flock and patch by uid on the first patch
data <- data %>% 
  mutate_at(vars(matches("patch")),
            as.character) %>% 
  left_join(flock_id,
            by = c("patch_i_unique_id" = "patch"))

# join patch data, basically id data, to flock data
tmp_patches <- filter(data_patches,
                      uid %in% flock_id$patch) %>% 
  select(id, uid)
data <- left_join(data, tmp_patches,
                  by = c("patch_i_unique_id" = "uid")) %>% 
  left_join(tmp_patches,
            by = c("patch_j_unique_id" = "uid"))

# get id and weights
edges_df <- select(data,
               matches("(id.)|flock|spatial")) %>% 
  rename(id_x = id.x, id_y = id.y) %>% 
  filter(id_x != id_y)
```

## Prepare network data

### Prepare subset-wise edgelist

Here, the subsets are the tide number and tidal stage. The edge-list indicates pairwise overlap.

```{r}
# group and nest
edges_df <- group_by(edges_df, 
                     flock) %>% 
  nest()

# count flock edges and remove small flocks
# ie, with fewer than 3 edges
edges_df <- mutate(edges_df,
                   n_edges = map_int(data, nrow)) %>% 
  filter(n_edges > 3)
```

### Prepare nodes data

```{r}
# expand nodes df to match edges data
nodes_df <-  
  summarise(edges_df, 
            id = map(data, 
                     function(df) {union(df$id_x, df$id_y)})) %>%
  mutate(id = map(id, function(df){
    
    df <- tibble(id = as.character(df)) %>% 
      left_join(data_id, by = "id")
    
    # remove nodes with no attributes
    df <- drop_na(df, gizzard_mass)
  }))
```

### Prepare flock networks

Join the edges and nodes data.

```{r}
network_df <- left_join(edges_df, nodes_df)
```

### Weigh edges by number of overlaps

Weigh the interactions between `id_x` and `id_y` by the number of such interactions among unique pairs of individuals.
A continuous option of weighing by summed overlap also exists.

```{r}
network_df <- mutate(network_df,
                     data = map(data, function(df) {
                       df <- count(df, id_x, id_y,
                                   name = "associations")
                     }))
```

Plot a histogram of associations among pairs in different flocks.

```{r}
# get the data
data_assoc <- bind_rows(network_df$data)
# where are the quantiles
quantile(data_assoc$associations, probs = c(1:10/10, 0.99))

ggplot(data_assoc)+
  geom_histogram(aes(associations))+
  scale_x_sqrt(breaks = c(0:10),
               labels = c(0:10))
```

Remove edges where the number of associations is above 4.

```{r}
# remove using a map over data
network_df <- mutate(network_df,
                     data = map(data, function(df) {
                       df <- filter(df, associations <= 10)
                     }))

# remove any data where there are now no edges
network_df <- filter(network_df,
                     map_lgl(data, function(x) {
                       nrow(x) >= 1
                     }))
```

Some 1213 flocks remain.

### Make networks

This data needs to be converted to `igraph` networks. The third column assocations is the edge weight.

```{r}
# prepare network objects for assortnet via igraph
network_df <- mutate(network_df,
                     net = map2(data, id, function(e, n){
                       
                       # exclude edges with no vertex attributes
                       e <- filter(e, 
                                   id_x %in% n$id,
                                   id_y %in% n$id) 
                       
                       tmp_net <- igraph::graph_from_data_frame(d = e,
                                                                directed = FALSE,
                                                                vertices = n)
                     }))
```

Remove networks with few (< 3) real edges.

```{r}
# check which graphs are (still) okay
network_df <- mutate(network_df, 
                     n_edges = map_int(net, function(n){
                       E(n) %>% length()
                     })) %>% 
  ungroup()

# remove bad graphs, ie, with fewer than 3 edges
# this is both for quality and practical reasons
min_edges <- 1
min_id <- 2
network_df <- filter(network_df, n_edges > min_edges)
```

### Get assortativity

```{r}
# get weighred assortativity by gizzard mass
network_df <- mutate(network_df,
                     assort_metrics = purrr::map(net, function(n){
                       
  adj <- igraph::as_adjacency_matrix(n,
                                     sparse = FALSE)
                       
  assort_gizzard <- assortnet::assortment.continuous(adj,
                                          V(n)$gizzard_mass)
                         
  assort_behav <- assortnet::assortment.continuous(adj,
                                                     V(n)$behav)

  assort_mass <- assortnet::assortment.continuous(adj,
                                                     V(n)$mass)
  
  assortment <- map_df(list(assort_gizzard
                            , assort_behav, assort_mass
                            ),
                       as_tibble) %>% 
    mutate(trait = c("gizzard"
                     , "behav", "mass"
                     ))
                     }))
```

Unnest the data.

```{r}
# prepare the data
plot_df <- select(network_df, 
                  flock, id, n_edges,
                  contains("assort")) %>% 
  
  # count flock size
  mutate(flock_size = map_int(id, nrow)) %>% 
  select(-id) %>% 
  pivot_longer(cols = contains("assort"))

# unnest
plot_df <- unnest(plot_df, "value")
```

## Flock attributes and assortativity

### Prepare flock data

```{r}
# filter for existing node data
nodes_df <- filter(nodes_df,
                   map_lgl(id, function(df){nrow(df)>1}))

# unnest flock id
flock_data <- nodes_df
# add flock data to patch data
data_patches <- left_join(data_patches,
                          flock_id,
                          by = c("uid" = "patch"))

# separate by tidal stage, where waterlevel < 55 is low tide
data_flock_attrs <- select(data_patches,
                           uid,
                           matches("(x|y|waterlevel)(_start)"),
                           flock) %>% 
  filter(uid %in% flock_id$patch) %>% 
  group_by(flock) %>% 
  summarise_at(vars(contains("start")),
               .funs = median)

# add waterlevel to flock
flock_data <- left_join(flock_data,
                        data_flock_attrs,
                        by = "flock")
flock_data <- mutate(flock_data,
                     tide_stage = if_else(waterlevel_start < 55, "low", "high"))
```

### Assortativity in high and low tide

```{r}
# get waterlevel
plot_df <- left_join(plot_df,
                     flock_data)

ggplot(plot_df)+
  geom_point(aes(waterlevel_start, r))+
  facet_wrap(~trait)
```

