---
editor_options: 
  chunk_output_type: console
---

# Pairwise associations in relation to traits

## Read in patch data and overlaps

```{r}
# to handle data
library(readr)
library(scales)
library(tidyr); library(tibble)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)
library(forcats)

# to work with networks
library(igraph)

# to plot
library(ggplot2)
library(scico)

# functions
ci <- function(x){qnorm(0.975)*sd(x, na.rm = T)/sqrt((length(x)))}
```

```{r}
# read in patch data
data_patches <- read_csv("data/data2018/data_2018_patch_summary_has_patches.csv") %>% 
  mutate(uid = as.character(1:nrow(.)))
# read in overlap data
data <- read_csv("data/data2018/data_spatio_temporal_overlap_2018.csv")
```

### Read in trait data

```{r}
# make nodes data -- this the individual identities
# add individual data to patch data
data_id <- readxl::read_excel("data/data2018/Biometrics_2018-2019.xlsx") %>% 
  filter(str_detect(`TAG NR`, "[a-zA-Z]+", negate = TRUE))

# a function for gizzard mass
get_gizzard_mass <- function(x, y) {-1.09 + (3.78*(x*y))}

# add gizzard mass
data_id <- mutate(data_id,
                  gizzard_mass = get_gizzard_mass(SH1, SW1))

# rename columns and drop ids without mass and gizzard mass
data_id <- data_id %>% 
  select(id = `TAG NR`, 
         wing = WING, mass = MASS, 
         gizzard_mass) %>% 
  distinct(id, .keep_all = TRUE) %>% 
  drop_na(gizzard_mass)

# add some exploration scores and tag info
data_behav <- read_csv("data/data2018/2018-19-all_exploration_scores.csv") %>% 
  filter(Exp == "F01")
data_tag <- read_csv("data/data2018/tag_info.csv") %>% 
  mutate(id = as.character(Toa_Tag))

# join all scores
data_id <- left_join(data_id, data_tag,
                     by = c("id")) %>% 
  left_join(data_behav, by = "FB")

# remove ids with no exploration
data_id <- mutate(data_id,
                  behav = Mean) %>% 
  # drop_na(behav) %>% 
  select(id, mass, gizzard_mass, behav)
```

### What is the empirical distribution of differences in gizzard mass?

### Filter out small patches

Each fix corresponds to 30s time.

```{r}
data_patches <- filter(data_patches,
                       nfixes > 3)

data <- data %>% 
  filter(patch_i_unique_id %in% data_patches$uid,
         patch_j_unique_id %in% data_patches$uid)
```

### Link patches with overlaps

```{r}
# convert to character
data <- mutate_at(data, vars(contains("patch")), as.character)
data <- left_join(data, data_patches,
                  by = c("patch_i_unique_id" = "uid")) %>% 
  left_join(data_patches,
            by = c("patch_j_unique_id" = "uid"))
```

### Count pairwise overlaps

```{r}
# first clip data into 3 sections with lims at 0, 55
data_summary <- data %>%
  mutate(tide_number = tide_number.x,
         waterlevel = waterlevel_start.x,
         tide_stage = case_when(waterlevel <= 0 ~ "low",
                                # between(waterlevel, 0, 55) ~ "medium",
                                waterlevel > 0 ~ "high",
                                T ~ NA_character_)) %>% 
  count(id.x, id.y, tide_number, tide_stage,
        name = "n_associations")

# link trait values
data_summary <- mutate_at(data_summary,
                          vars(matches("id")),
                          as.character)
data_summary <- left_join(data_summary,
                          data_id,
                          by = c("id.x" = "id")) %>% 
  left_join(data_id,
            by = c("id.y" = "id"))

# get difference in traits
data_summary <- data_summary %>% 
  mutate(diff_gizzard = abs(gizzard_mass.x - gizzard_mass.y),
         diff_gizzard_round = plyr::round_any(diff_gizzard, 0.5),
         diff_behav = abs(behav.x - behav.y),
         tide_stage = forcats::as_factor(tide_stage),
         tide_stage = fct_relevel(tide_stage,
                                  "low", "high")) %>% 
  drop_na(diff_gizzard)
```

## Relate associations to trait differences

### An exploratory plot

```{r}
# make an exploratory plot
data_summary_mean <- data_summary %>% 
  group_by(diff_gizzard_round, tide_stage) %>% 
  summarise_at(vars("n_associations"),
               .funs = list(n_assoc_mean = mean, 
                            n_assoc_ci = ci))
ggplot()+
  geom_jitter(data = data_summary %>% 
                sample_frac(0.1),
              aes(diff_gizzard,
                  n_associations),
              size = 0.1,
              col = "black",
              alpha = 0.2)+
  # geom_point()+
  geom_errorbar(data = data_summary_mean,
                aes(diff_gizzard_round,
                    ymin = n_assoc_mean - n_assoc_ci,
                    ymax = n_assoc_mean + n_assoc_ci),
                width = 0.2,
                col = "indianred")+
  theme_bw(base_family = "sans")+
  facet_grid(~tide_stage,
             labeller = label_both)+
  coord_cartesian(ylim = c(1, 5))+
  labs(x = "difference in gizzard mass (g)",
       y = "# associations (patch overlaps)")

# save figure
ggsave(filename = "figs/fig_diff_gm_n_assoc.png",
       dpi = 300,
       height = 3, width = 8)
```

Small gizzard mass differences are over-represented as expected from a population with normally distributed traits. This requires subsampling based on difference bins.

### Subsample the data

```{r}
# count the number of data in each class
data_summary %>% 
  count(diff_gizzard_round)

# count the difference in gizzards per pairwise association
data_summary <- data_summary %>% 
  group_by(id.x, id.y) %>% 
  nest() %>% 
  ungroup() %>% 
  mutate(uid_pair = seq_len(nrow(.)))

# then unnest
data_summary <- unnest(data_summary,
                       col = "data")

# plot to see real pairwise distribution of differences
data_summary %>% 
  distinct(uid_pair, .keep_all = T) %>% 
  ggplot()+
  geom_bar(aes(x = diff_gizzard_round
               ),
           fill = "grey", col = "black")
```

### Compare observed and expected distributions of gizzard mass

```{r}
# how many observations in the full data?
# scales well with the true pairwise overlaps
#fig_observed_gm_diff <- 
data_summary %>% 
  ggplot()+
  geom_bar(aes(x = diff_gizzard_round
               ),
           fill = "grey")+
  geom_bar(data = data_summary %>% 
             distinct(uid_pair, .keep_all = T),
           aes(x = diff_gizzard_round+0.2,
               y = ..count..*10),
           fill = "black",
           width = 0.45)+
  scale_x_continuous(breaks = seq(0,7,1))+
  scale_y_continuous(sec.axis = dup_axis(trans = ~./20,
                                         name  = "# unique pairwise differences in gizzard mass"),
                     labels = scales::label_comma(),
                     name = "# observed pairwise differences in gizzard mass")+
  coord_cartesian(expand = F)+
  theme_bw(base_family = "sans",
           base_size = 6)+
  # theme(panel.grid = element_blank())+
  facet_grid(~ tide_stage)+
  labs(x = "difference in gizzard mass (g)",
       title = "observed vs expected diff. in gizzard mass")

# save figure
ggsave(fig_observed_gm_diff,
       filename = "figs/fig_obs_exp_gm_diff.png",
       dpi = 300, height = 3, width = 8)
```

### Subsample for even coverage

```{r}
# filter for differences above 5 and subsample as many
# as supported
data_subsample <- data_summary %>% 
  filter(diff_gizzard_round <= 3) %>% 
  group_by(tide_stage, diff_gizzard_round) %>% 
  sample_n(1480)
```

## Statistical modelling

### Fit a GLMM for number of associations

Include difference in behaviour score as a predictor.

```{r}
# run a single canonical model
library(lmerTest)
model_overlap_full <- glmer(n_associations ~ diff_gizzard * tide_stage +
                         diff_behav * tide_stage +
                         (1|tide_number) +
                         (1|uid_pair),
                       data = data_subsample,
                       family = "poisson")

# run an alternative model with only behaviour
model_overlap_reduced <- glmer(n_associations ~ 
                         diff_behav * tide_stage +
                         (1|tide_number) +
                         (1|uid_pair),
                       data = data_subsample,
                       family = "poisson")
```

### AIC and R^2 comparison

Compare the AIC weights after looking at the model summaries.

```{r}
summary(model_overlap_full)

summary(model_overlap_reduced)
```

It seems that differences in behaviour are sufficient to explain the observed number of overlaps. Is this borne out by the AIC scores of the two models?

```{r}
# get aic difference
AIC(model_overlap_full) - AIC(model_overlap_reduced)

# get R2
MuMIn::r.squaredGLMM(model_overlap_reduced)
```

With similar AIC scores and R<sup>2</sup> values, we select the reduced model by the parsimony principle, and write the model output to file.

```{r}
model_output = capture.output(summary(model_overlap_reduced))

# save it to file
write_lines(x = model_output, path = "results/model_overlap.txt")
```

## Network modelling

Make a population network from the subsetted edgelist. First prep the data.

### Prepare the data

```{r}
# make an edges dataframe
net_df <- data_summary %>% 
  select(matches("id."),
         matches("tide"),
         n_associations,
         -uid_pair) %>% 
  group_by(tide_number, tide_stage) %>% 
  nest()

# make a node df
net_df <- net_df %>% 
  mutate(id = map(data, function(df) {
    unique_ids <- union(df$id.x, df$id.y)
    
    df <- tibble(id = as.character(unique_ids)) %>% 
      left_join(data_id, by = "id")
    
    # remove nodes with no attributes
    df <- drop_na(df, gizzard_mass)
    
  }))
```

### Make the networks

```{r}
net_df <- mutate(net_df,
                 net = map2(data, id, function(e, n){
                   
                   # exclude edges with no vertex attributes
                   e <- filter(e, 
                               id.x %in% n$id,
                               id.y %in% n$id) 
                   
                   tmp_net <- igraph::graph_from_data_frame(d = e,
                                                            directed = FALSE,
                                                            vertices = n)
                 }))
```

### Visualise some networks

```{r}
library(ggraph)
# visualise a network
ggraph(net_df$net[[1]], layout = "dh") + 
    geom_edge_fan(show.legend = FALSE,
                  edge_colour = "grey",
                  edge_alpha = 0.5,
                  aes(edge_width = n_associations)) + 
    geom_node_point(aes(size = gizzard_mass)) + 
    theme_graph(foreground = 'steelblue', fg_text_colour = 'white')+
    theme(legend.position = "none")
```

### Get network assortativity

```{r}
net_df <- mutate(net_df,
                 assort_gm = purrr::map_dbl(net, function(n){
                       
  adj <- igraph::as_adjacency_matrix(n,
                                     attr = "n_associations",
                                     sparse = FALSE)
  
  assort_gizzard <- assortnet::assortment.continuous(adj,
                                                     V(n)$gizzard_mass)
  assort_gizzard <- unlist(assort_gizzard)
                 }))
```

Plot to see.

```{r}
# plot figure
ggplot(net_df)+
  geom_histogram(aes(assort_gm,
                     y = ..density..),
                 fill = "steelblue")+
  geom_boxplot(aes(x = assort_gm, y = -1),
               width = 1)+
  geom_vline(xintercept = 0, lty = 2)+
  coord_flip()+
  theme_grey(base_size = 8,
             base_family = "TT Arial") +
  facet_grid(~ tide_stage, 
             labeller = label_both)+
  labs(x = "assortativity of gizzard mass")

ggsave(filename = "figs/fig_assort_tidestage.png",
       dpi = 300, height = 4, width = 4)
```

Plot assortativity over tide stages.