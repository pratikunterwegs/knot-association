---
editor_options: 
  chunk_output_type: console
---

# Finding networks from patch data

**Workflow:**

1. Read in patch data, and link to individual trait data.
2. Remove individuals with traits within 1 SD of the population mean,
and their patches.
3. Find communities in the remaining patches.
4. Filter communities for data quality, and calculate assortativity.
5. Relate assortativity to flock attributes:
  - waterlevel start
  - flock size

## Read in patch data and overlaps

```{r}
# to handle data
library(readr)
library(scales)
library(tidyr); library(tibble)
library(magrittr)
library(dplyr)
library(purrr)
library(stringr)

# to work with networks
library(igraph)

# to plot
library(ggplot2)
library(scico)
```

```{r}
# read in patch data
data_patches <- read_csv("data/data2018/data_2018_patch_summary_has_patches.csv") %>% 
  mutate(uid = as.character(seq_len(nrow(.))))
# read in overlap data
data <- read_csv("data/data2018/data_spatio_temporal_overlap_2018.csv")
```

### Read in trait data

```{r}
# make nodes data -- this the individual identities
# add individual data to patch data
data_id <- readxl::read_excel("data/data2018/Biometrics_2018-2019.xlsx") %>% 
  filter(str_detect(`TAG NR`, "[a-zA-Z]+", negate = TRUE))

# a function for gizzard mass
get_gizzard_mass <- function(x, y) {-1.09 + (3.78*(x*y))}

# add gizzard mass
data_id <- mutate(data_id,
                  gizzard_mass = get_gizzard_mass(SH1, SW1))

# rename columns and drop ids without mass and gizzard mass
data_id <- data_id %>% 
  select(id = `TAG NR`, 
         wing = WING, mass = MASS, 
         gizzard_mass) %>% 
  distinct(id, .keep_all = TRUE) %>% 
  drop_na(gizzard_mass)

# add some exploration scores and tag info
data_behav <- read_csv("data/data2018/2018-19-all_exploration_scores.csv") %>% 
  filter(Exp == "F01")
data_tag <- read_csv("data/data2018/tag_info.csv") %>% 
  mutate(id = as.character(Toa_Tag))

# join all scores
data_id <- left_join(data_id, data_tag,
                     by = c("id")) %>% 
  left_join(data_behav, by = "FB")

# remove ids with no exploration
data_id <- mutate(data_id,
                  behav = Mean) %>% 
  # drop_na(behav) %>% 
  select(id, mass, gizzard_mass, behav)
```

### Filter out small patches

Each fix corresponds to 30s time.

```{r}
data_patches <- filter(data_patches,
                       nfixes > 3)

data <- data %>% 
  filter(patch_i_unique_id %in% data_patches$uid,
         patch_j_unique_id %in% data_patches$uid)
```


## Overlaps in time and space

### When do overlaps happen?

When, in terms of waterlevel and season, do most overlaps occur?

```{r}
# convert to character
data <- mutate_at(data, vars(contains("patch")), as.character)
data <- left_join(data, data_patches,
                  by = c("patch_i_unique_id" = "uid")) %>% 
  left_join(data_patches,
            by = c("patch_j_unique_id" = "uid"))
```

Count at rounded waterlevel, and tide number.

```{r}
# round waterlevel start
data_overlap_waterlevel <- data %>% 
  mutate(waterlevel_round = plyr::round_any(waterlevel_start.x, 20)) %>% 
  count(waterlevel_round)

# plot
ggplot(data_overlap_waterlevel)+
  geom_col(aes(x = waterlevel_round, y = n),
           fill = "grey", col = "black", size = 0.2)+
  theme_bw()+
  labs(x = "waterlevel (cm NAP)",
       y = "# overlaps",
       caption = "Waterlevel is waterlevel_start.x rounded to 20 cm.
       15 tidal cycles is approx. 1 week.",
       title = "# patch overlaps ~ waterlevel")

ggsave(filename = "figs/fig_overlaps_waterlevel.png",
       dpi = 300, height = 4, width = 5)
```


### Where do overlaps happen?

Load the overlaps spatial object.

```{r}
overlaps <- sf::st_read("data/data2018/spatials/patch_overlap_2018.gpkg")
overlaps <- filter(overlaps, uid %in% data_patches$uid)

# get centroid of overlap
overlaps <- mutate(overlaps,
                   centroid = sf::st_centroid(geom))

# get only uid - overlap id, and centroid
overlaps <- select(overlaps,
                   uid, overlap_id, centroid) %>% 
  sf::st_drop_geometry()

# get centroid as coords
overlaps <- bind_cols(overlaps, 
                      as_tibble(sf::st_coordinates(overlaps$centroid))) %>% 
  select(-centroid)

# type to character
overlaps <- overlaps %>% 
  mutate_at(vars(matches("id")), as.character)
```


Where on the mudflats do overlaps happen?

```{r}
# read griend
griend <- sf::st_read("map.osm", layer = "multipolygons") %>% 
  filter(name %in% c("Richel", "Griend")) %>% 
  sf::st_transform(32631)

# count at x and y
data_overlap_space <- data %>% 
  left_join(overlaps, 
            by = c("patch_i_unique_id" = "uid",
                   "patch_j_unique_id" = "overlap_id")) %>% 
  mutate(x_round = plyr::round_any(X, 100),
         y_round = plyr::round_any(Y, 100)) %>% 
  count(x_round, y_round)

# plot
ggplot(data_overlap_space)+
  geom_tile(aes(x = x_round, 
                y = y_round,
                fill = n))+
  geom_sf(data = griend,
          fill = NA, size = 1,
          col = "black")+
  scale_fill_scico(trans = "log10", 
                   palette = "lajolla", 
                   values=c(0, 1), 
                   direction = 1,
                   breaks = c(10^c(0:4)))+
  labs(caption = "X and Y are coords_start.x rounded to 200m.",
       title = "# patch overlaps ~ space")

ggsave(filename = "figs/fig_overlaps_space.png",
       dpi = 300)
```

### Where AND when do overlaps happen?

```{r}
# count at x and y
data_overlap_spacetime <- data %>% 
  left_join(overlaps, 
            by = c("patch_i_unique_id" = "uid",
                   "patch_j_unique_id" = "overlap_id")) %>% 
  mutate(x_round = plyr::round_any(X, 200),
         y_round = plyr::round_any(Y, 200),
         waterlevel_round = plyr::round_any(waterlevel_start.x, 30)) %>% 
  count(x_round, y_round, waterlevel_round)

# plot
ggplot(data_overlap_spacetime)+
  geom_tile(aes(x = x_round, 
                y = y_round,
                fill = n))+
  geom_sf(data = griend,
          fill = NA, size = 1,
          col = "black")+
  scale_fill_scico(trans = "log10", 
                   palette = "lajolla", 
                   values=c(0, 1), 
                   direction = 1,
                   breaks = c(10^c(0:4)))+
  facet_wrap(~waterlevel_round, labeller = label_both)+
  theme_bw()+
  labs(caption = "X and Y are coords_start.x rounded to 200m.",
       title = "# patch overlaps ~ space")

ggsave(filename = "figs/fig_overlaps_spacetime.png",
       dpi = 300)
```

## Association networks based on space-time overlap subsets

### Prepare subsets of data

Round each overlap's X, Y and waterlevel coordinates, and construct a network from all overlaps in the same subset of X, Y, time.

```{r}
# make data here
data_overlap <- data %>% 
  left_join(overlaps, 
            by = c("patch_i_unique_id" = "uid",
                   "patch_j_unique_id" = "overlap_id")) %>% 
  mutate(x_round = plyr::round_any(X, 100),
         y_round = plyr::round_any(Y, 100),
         waterlevel_round = plyr::round_any(waterlevel_start.x, 30))

# select columns
data_overlap <- select(data_overlap,
                       contains("round"),
                       id.x, id.y)

# count interactions among unique pairs
data_overlap <- group_by(data_overlap,
                         x_round, y_round, waterlevel_round) %>% 
  count(id.x, id.y)

# nest in prep for making a network
data_overlap <- nest(data_overlap)

# remove cases where there are fewer than 3 rows
edge_df <- filter(data_overlap,
                       map_lgl(data, function(x) {
                         nrow(x) >= 3
                       }))
```

### Get node data

```{r}
# expand nodes df to match edges data
node_df <-  
  summarise(edge_df, 
            id = map(data, 
                     function(df) {union(df$id.x, df$id.y)})) %>%
  mutate(id = map(id, function(df){
    
    df <- tibble(id = as.character(df)) %>% 
      left_join(data_id, by = "id")
    
    # remove nodes with no attributes
    df <- drop_na(df, gizzard_mass)
  }))
```


### Make networks using the edgelist and nodelist joined together.

```{r}
# make network df
network_df <- left_join(edge_df, node_df)

# remove edges with no node data
network_df <- filter(network_df,
                     map_lgl(id, function(df) {
                       nrow(df) > 1
                     }))

# make networks for each of the many subsets
network_df <- mutate(network_df,
                       net = map2(data, id, function(e_df, n_df) { 
                         # exclude edges with no vertex attributes
                         e_df <- filter(e_df, 
                                   id.x %in% n_df$id,
                                   id.y %in% n_df$id)
                         igraph::graph_from_data_frame(d = e_df,
                                                       vertices = n_df,
                                                       directed = F)}
                         ))
```

### Remove networks with few edges

```{r}
# count edges
network_df <- mutate(network_df, 
                     n_edges = map_int(net, function(n){
                       E(n) %>% length()
                     })) %>% 
  ungroup()


# remove bad graphs, ie, with fewer than 3 edges
# this is both for quality and practical reasons
min_edges <- 1
min_id <- 2
network_df <- filter(network_df, n_edges >= min_edges)
```

## Get assortativity

### Get assortativity on node attributes

```{r}
# get weighred assortativity by gizzard mass
network_df <- mutate(network_df,
                     assort_g_mass = unlist(purrr::map(net, function(n){
                       
                       # adj <- igraph::as_adjacency_matrix(n,
                       #                                    sparse = FALSE,
                       #                                    attr = "n")
                       
                       assortativity.nominal(n, types = V(n)$gizzard_mass)
                     })))
```

### Mean assortativity in space and time

```{r}
assort_df <- network_df %>% 
  group_by(x_round, y_round,
           waterlevel_round) %>% 
  summarise(med_assort = median(assort_g_mass))
```

```{r}
# plot
ggplot(assort_df)+
  geom_tile(aes(x = x_round, 
                y = y_round,
                fill = med_assort))+
  geom_sf(data = griend,
          fill = NA, size = 1,
          col = "black")+
  scale_fill_gradient2(low = "blue",
                       high = "red",
                       mid = "grey90",
                       limits = c(-1,1))+
  facet_wrap(~ waterlevel_round, labeller = label_both)+
  theme_bw()+
  labs(caption = "X and Y are coords_start.x rounded to 200m.",
       title = "median assortativity in space and time")

ggsave(filename = "figs/fig_overlaps_spacetime.png",
       dpi = 300)
```

